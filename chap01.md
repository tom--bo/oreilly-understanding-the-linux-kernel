# chapter-01 概要

Linuxは1991年から最初はIntel 80386プロセッサベースのIBM PC互換機用のOSとして、Linus Torvaldsにより開発された。  
Linuxの魅力の１つは商用ではないことで、GNU一般公衆利用許諾契約書(GNU General Public License:以降GPL)に基づいて公開されている。  
そのため、誰でも自由に調べたり、ダウンロードしたりできる。  

## 1.1 LinuxとほかのUNIX系カーネル

市場にはさまざまなUNIX系システムが出回っている  
商用UNIXはすべて、IEEEのPOSIX(Portable Operating Systems based on Unix)やX/OpenのCAE(Common Applications Environment)といった一般的な標準規格に従う傾向がある。  
現在の標準規格では、API(Application Programming Interface)、つまり、ユーザプログラムが実行される環境のみが規定されている  
共通のユーザインタフェースを定義するため、UNIX系カーネルでは多くの場合基本的な設計思想や機能が共有されている。  
この点はLinuxは他のUNIX系OSと類似しているので、Linuxで学んだことはUNIXの理解にも役立つ。

Linuxカーネルのバージョン2.6はIEEE POSIX標準への準拠を目指しているので、既存のUNIXプログラムの殆どがLinuxシステム上でコンパイルして実行できるようになる。  
更に、仮想ファイルシステム、軽量プロセス、UNIXシグナル、SVR4プロセス間通信、対象型マルチプロセッサ(Symmetric MultiProcessor(以下SMP))システムが扱えるなど、近代的なUNIX OSの持つ機能をLinuxは全て備えている。  

Linus Torvaldsはカーネルを書き始める時に、Maurice Bach著「The Design of the Unix Operating System」のようなUNIXの古典的な本を参考にしたため、UNIXの設計方針に偏っているところがある。
以下にLinuxと他の代表的な商用UNIXカーネルを比較、評価した結果を挙げる。

- モノリシックカーネル(一枚岩)
  - Linuxカーンるはおおきく複雑で自己完結的なプログラム
  - UNIX系OSの殆どもモノリシック
  - モノリシックと相対する構造をもつのは、Mac OS XとGNU Hurd OSが有名でこれらは、マイクロカーネルという方式をとっている
- 伝統的なUNIXカーネルのコンパイルとリンクは静的
  - 近代的なカーネルならば、たいていカーネルコードの一部を動的に組み込んだり、削除したりできる
  - これはモジュールと呼ばれ、典型的な例はデバイスドライバ
  - Linuxのモジュール支援機構は非常にす売れていて、必要に応じてこれらを自動的に組み込んだり削除したりできる
- カーネルスレッド
  - 近代的なUNIXカーネルは、カーネルスレッドの集合体として構成されている
  - カーネルスレッドとは、独立してスケジューリングが可能な実行コンテキスト
  - カーネルスレッドには、ユーザプログラムに対応するものもあれば、カーネルの関数に対応するだけのものもある
  - カーネルスレッドは共通のアドレス空間で実行されるので、プロセス間のコンテキスト切り替えよりずっと効率が良いことが多い
  - Linuxでは、カーネルスレッドを、定期的にいくつかのカーネル関数を実行するという限定された方法でしか使用していない
- マルチスレッドアプリケーション支援
  - マルチスレッドなアプリケーションとは、アプリケーションのデータのかなりの部分を共有し、比較的独立した多くの処理の流れを取り扱えるように設計されたユーザプログラムのこと
  - マルチスレッドなユーザアプリケーションは多くの軽量プロセス(LightWeight Process、以下LWP)から構成される場合もある
  - Linuxでは、独自のLWPを定義している
    - 基本的な実行コンテキスト(プロセスと同じ)とみなされ
    - 標準的ではないclone()というシステムコールで処理される
- マルチプロセッサ支援
  - SMP機能を提供し、NUMAのような異なるメモリモデルのものも扱える
- ファイルシステム
  - Linuxの標準ファイルシステムに多くの機能が追加された
  - Ext2, Ext3, ReiserFS, JFS, XFSなど
- STREAMS
  - SVR4で導入されているSTREAMS I/Oサブシステムは、最近ではほとんどのUNIXカーネルに用意されるが、Linuxにこれに類似するものはない

以上のような特徴の他に、商用のUNIXと比べて以下のような利点がある

- Linuxは無料である
- Linuxでは全ての構成部分をカスタマイズできる
- Linuxはローエンドで安価なハードウェアプラットフォーム上でも動作する
- Linuxは強力である
- Linuxカーネル開発者は卓越したプログラマである
- Linuxカーネルは非常に小さくすることができる
- Linuxは多くの一般的なOSとの互換性が高い
- Linuxには優れたサポートがある

## 1.2 ハードウェア依存

Linuxではソースコードのハードウェアに依存する部分と非依存の部分を明確に区別している。  
そのため、archディレクトリとincludeディレクトリの両方に23種類のハードウェアプラットフォームに対応するサブディレクトリをおいている。

プラットフォームの標準名（ここでは代表的なのいくつか）
- arm, arm26
- i386
- MIPS
- x86_64

## 1.3 Linuxのバージョン

Linuxカーネル2.5までは単純な番号体型でバージョンをつけていた。  
ピリオドによって3つに区切られた、最初の2つがバージョンを特定し、３つめがリリース番号  
2.5までは2つ目の数字が偶数であれば安定版、奇数であれば開発版を意味していたが、2.6以降はそうではない。


## 1.4 オペレーティングシステムの基本概念

この本では多くの場合は「オペレーティングシステム」と「カーネル」を同義として扱う。  
オペレーティングシステムは、2つの重要な役割がある
- 低水準のプログラマブルなハードウェアを制御する
- コンピュータシステム上で実行するアプリケーションに実行環境を提供する

OSの中にはWindowsのようにユーザプログラムにハードウェアを直接操作することを認めているものもある。  
一方、UNIX系のOSではユーザプログラムにはこれらを隠蔽している

近代的なOSではこの仕組みを実現するために、ハードウェアに備わっている特定の機能に依存している。  
具体的には、ハードウェアはCPUに少なくとも2つの異なる実行モードを用意している  
それぞれをユーザモードとカーネルモードと呼ぶ  
以降のこの章ではこれらの基本的な概念を紹介し、2章以降ではLinuxカーネル内部機構を理解するための内容が続く。

### 1.4.1 マルチユーザシステム

マルチユーザシステムとは2人以上のユーザが様々なアプリケーションを並行して独立に実行することが可能なコンピュータ  
- 並行に：複数のアプリケーションが同時に動作状態になり、CPU、メモリ、ディスクなどの様々な資源を取り合うことができる
- 独立に：他のユーザのアプリケーションの動作とは無関係に処理を実行できる

マルチオペレーティングシステムには以下のような機能が必要
- ユーザIDを確認する認証機構
- 同じシステム上で他のアプリケーションの動きを止めてしまう可能性のあるバグをもつユーザプログラムに対する保護機構
- 悪意のあるユーザプログラムに対するする保護機構
- 各ユーザに割り当てる資源の量を制限するアカウンティング機構

保護機構の安全性を保証するために、オペレーティングシステムはハードウェア(CPUの特権モード)による保護を利用する必要がある。


### 1.4.2 ユーザとグループ

マルチユーザシステムでは、マシン上に各ユーザの個人領域がある。
ユーザは全て、ユーザID(UID)と呼ばれる一意の番号によって識別される。  
ユーザがセッションを開始するには、ログイン名とパスワードが要求される。
他のユーザとデータを共有するために各ユーザは１つ以上のユーザグループに所属する。  
グループはユーザグループID(GID)によって識別される。  
全てのUNIX系オペレーティングシステムには、ルート(スーパユーザ、スーパバイザ)と呼ばれるシステムの管理用ユーザがある。  
ルートユーザはシステムの全てのユーザプログラムの実行を操作することができる。


### 1.4.3 プロセス

プロセスは「実行中のプログラムのインスタンス」または、動作中のプログラムの「実行コンテキスト」と定義できる。  
プロセスは1つのアドレス空間において、命令の並び（命令シーケンス）を1つ以上実行する。  
マルチユーザシステムでは、複数のプロセスが同時に動作状態になり、システム資源（おもにCPU）を取り合うという実行環境を提供しなければならない。  
複数のプロセスが同時に動作状態になることが可能なシステムのことを、「マルチプログラミングシステム」または「マルチプロセッシングシステム」という。  

一般的にCPUの数は限られているので、同時に実行できるのは数プロセスだけ。  
OSのスケジューラが実行するプロセスを選択する。  
マルチユーザシステムのプロセスは「プリエンプト可能」でなければならない。つまり、OSが各プロセスがCPUを獲得していた時間を管理し、定期的にスケジューラを作動する。  
UNIX系OSでは「プロセス/カーネル」モデルが採用されていて、各プロセスは自分がマシン上の唯一のプロセスであり、OSのサービスを専有していると錯覚している。  

### 1.4.4 カーネルアーキテクチャ

UNIXカーネルの殆どはモノリシック。カーネル内の各レイヤはカーネルプログラム全体へと統合され、カレントプロセスの代わりにカーネルモードで動作する。  
対象的に、マイクロカーネル方式のOSでは、カーネルに要求される機能はわずかである。  
一般的には、数種類の動機プリミティブ、単純なスケジューラ、プロセス間通信機構などがある。  
その他のOSレイヤの機能、メモリアロケータ、デバイスドライバ、システムコールハンドラなどは、マイクロカーネル上で動作するいくつかのシステムプロセスが処理する。  

OSの学術的な研究は、マイクロカーネルの方向に進んでいる。  
しかし、マイクロカーネル方式のOSは一般的にモノリシックカーネルより実行速度が遅くなる。  
一方で、いくつかの点でマイクロカーネルに理論的な利点もある。
- システムプログラマにモジュール化方式を強要する
- マイクロカーネルのOSシステムを他のアーキテクチャに移植するのは比較的簡単
- モノリシックなカーネルよりRAMを効率よく利用できる

性能の低下を招くことなくマイクロカーネルの理論的な利点を効率よく実現できるようにカーネルはモジュール機能を提供する。  
モジュールは実行中にコードをカーネルに組み込む・削除することが可能なオブジェクトファイル。  

モジュールの主な利点には、次のようなものがある
- モジュール化方式
  - 実行時に組み込まれ削除される可能性がある
  - そのために明確に定義されたインタフェースがあり、新しいモジュールの開発が用意
- プラットフォーム独立性
  - ハードウェアプラットフォームに依存しない
  - ただし、ハードウェアの機能に依存することはある
- メインメモリの使用料を節約
  - 機能が必要になった時に実行中のカーネルに読み込める
  - 必要がなくなれば削除もできる
- 性能に関して妥協しない
  - 一度組み込まれてしまえば、カーネルに静的に組み込まれているオブジェクトコードと同様なので、明示的なメッセージパッシングは必要ない

## 1.5 UNIXファイルシステムの概要

UNIXオペレーティングシステムの設計の中心は、ファイルシステムにある。  
今後の章でもしばしば触れるので、この章では最も重要なものについて解説する。

### 1.5.1 ファイル

ファイルはツリー構造の名前空間に系統立てられている。(図1-1)  
- ルートディレクトリ
  - ツリーのルートにあるディレクトリ
- 作業ディレクトリ
  - プロセスごとにある現在使用しているディレクトリ
- パス名
  - ファイルに到達するまでの一連のディレクトリ名
  - 絶対パス名：先頭がスラッシュの場合。ルートディレクトリから開始
  - 相対パス名：開始地点がプロセスの作業ディレクトリ


### 1.5.2 ハードリンクとソフトリンク

ディレクトリ内のファイル名は、「ファイルハードリンク」または「リンク」と呼ばれている。  
1つのファイルの実態に対しtえ、同じディレクトリ内あるいは違うディレクトリ内に複数のリンクを持つことができる。  
つまり1角ファイルの実態が複数のファイル名を持つことができる。  

ハードリンクには２つの制限がある。
- ディレクトリのハートリンクは作れない
  - ディレクトリツリーが循環グラフになるのを防ぐため
- リンクは、同じファイルシステム内に含まれているファイルに対してのみ作成できる

同じファイルシステム内でしかリンクを作成できないのは近代のOSでは非常に不便。  
この制限を克服するために「ソフトリンク（シンボリックリンク）」が作成された。
シンボリックリンクは、別のファイルへの任意のパス名を含む小さなファイル。  
存在しないファイルを指し示すことも可能。


### 1.5.3 ファイルの種類

UNIXのファイルは以下のどれかになる。

- 通常ファイル
- ディレクトリ
- シンボリックリンク
- ブロック型デバイスファイル
- キャラクタ型デバイスファイル
- パイプ、名前付きパイプ、（FIFOとも呼ばれる）
- ソケット

これらの詳細は18章で、デバイスファイルについては13章で、パイプとソケットは1.6.5及び19章で述べる。


### 1.5.4 ファイルディスクリプタとiノード

UNIXではファイルの内容とファイル情報とを明確に区別している。  
ファイルを取り扱うのにファイルシステムが必要とする全ての情報はiノードに含まれている。  
ファイルシステムとそれを取り扱うカーネルの関数は、UNIXシステムの種類によって様々だが、少なくともPOSIX標準が定めている以下の属性は必ず提供されなければならない。  
- ファイルの種類
- ファイルに関連つけられているハードリンクの数
- ファイルのバイト長
- デバイス番号（ファイルがあるデバイスの識別子）
- ファイルシステムにおいてファイルを識別するiノード番号
- ファイル所有者のUID
- ファイルのGID
- iノード変更時刻、最終アクセス時刻、最終変更時刻を示す複数のタイムスタンプ
- アクセス権とファイルのモード


### 1.5.5 アクセス権とファイルのモード

ファイルのユーザは次の3つに分類できる。  
- ファイルの所有者であるユーザ
- ファイルのグループと同じグループに属する所有者以外のユーザ
- それ以外の全てのユーザ

上記のユーザごとに、読み取り、書き込み、実行3種類のアクセス権がある。  
したがって、ファイルのアクセス権は9つのバイナリフラグからなる。  
また、ファイルのモードを定義する補助的なフラグが3つある
- suid (Set User ID)
  - ファイルの実行は、通常プロセス所有者のユーザIDで実行される
  - suidが設定されていると、プロセスはファイル所有者のUIDで実行される
- sgid (Set Group ID)
  - 通常はプロセスのユーザグループで実行する
  - sgidが設定されていると、ファイルのGIDで実行される
- sticky
  - stickyフラグが設定されていると、実行が終了したあともメモリ内にプログラムを残しておくようにカーネルへ要求する

### 1.5.6 ファイルを取り扱うシステムコール

ユーザプロセスは低水準なハードウェアを直接操作することは出来ない。  
実際のファイル操作はカーネルモードで行われる必要がある。  
したがって、UNIXカーネルはファイルを操作するシステムコールを定義している。  
以降ではファイルを操作する主なシステムコールについて説明する


#### 1.5.6.1 ファイルのオープン

プロセスがアクセスできるのは「オープンされている」ファイルだけ  
プロセスはファイルをオープンするために以下のシステムコールを呼ぶ
```
fd = open(path, flag, mode)
```
- path
  - オープンするファイルの相対または絶対パス
- flag
  - ファイルをオープンする方法
    - 読み取り専用、書き込み専用など
    - ファイルが存在しない場合に新しく作成するかどうかの指定など
- mode
  - 新しく作成するファイルのアクセス権

このシステムコールはオープンファイルオブジェクトを作成し、ファイルディスクリプタという識別子を返す。  
オープンファイルオブジェクトには、以下のようなものが含まれる
- ファイルを操作するためのデータ
  - ファイルをオープンした時に指定したフラグなど
  - カーネルのバッファメモリ領域へのポインタや、次回操作が行われるファイル中の現在位置を示すoffsetメンバ
  - ファイルポインタと呼ばれることもある
- 複数のカーネル関数へのポインタ
  - プロセスから呼び出すことができるようにする
  - 呼び出し可能な関数の集合は、flag引数の値による

オープンファイルオブジェクトの詳細については、12章で述べる。  
ここではPOSIXで指定されているいくつかの一般的な属性を説明するだけにする。

- オープンファイルオブジェクトには、オープンされたファイルとプロセスとのやり取りや、制御に関連するデータが含まれている
- 一方、ファイルディスクリプタとは、どのやり取りかを指し示すもの、そのため、複数のファイルディスクリプタが同一プロセス内で同じオープンファイルオブジェクトを指すこともある。
- 複数のプロセスが同じファイルを同時にオープンすることもある。
  - この場合それぞれのプロセスに対して、別々のオープンファイルオブジェクトとともに、別々のファイルディスクリプタを割り当てる。
  - このような場合、UNIXファイルシステムでは、複数のプロセスに対して、同期処理の機構を提供しない
  - ただし、ファイルの全体あるいは一部に対して、プロセス同士が同期を取れるように、flock()などのシステムコールが利用できる(12章参照)

プロセスはcreate()システムコールを呼び出すこともでき、open()と全く同様に処理される。

#### 1.5.6.2 オープンされたファイルへのアクセス

UNIXはファイルの順次アクセスを前提としている。  
つまり、read()とwrite()システムコールは必ず現在のファイルポンターの位置を参照する。  
現在位置を変更したい場合には、プログラムは明示的にlseek()システムコールを呼び出す必要がある。  

lseek()システムコールには次のような引数が必要
```
newoffset = lseek(fd, offset, whence);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- offset
  - ファイルポインタの新しい値を計算するのに使用される符号付き整数値
- whence
  - 新しい一の計算方法を指定する値
    - offsetの値に数値0を足す
    - 現在のファイルポインタにoffsetの値を加える
    - 末尾のバイトの一にoffsetの値を加える

read()システムコールは以下の引数を必要とする
```
nread = read(fd, buf, count);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- buf
  - プロセスのアドレス空間にある、データ転送先のバッファアドレス
- count
  - 読み取るバイト数

read()システムコールはオープンされているファイルのoffsetメンバの現在地から始まるcountバイトをfdを持つファイルから読み取ろうとする。  
返されるnreadの値は、実際に読み取られたバイト数を示す。  
EOFや空のパイプなどの場合、カーネルがcountバイト数の読み取りに成功しないこともある。  

#### 1.5.6.3 ファイルのクローズ

ファイルディスクリプタfdい関連するオープンファイルオブジェクトを開放する
```
res = close(fd);
```

プロセスが終了された時も、その時点でまだオープンされていたファイルすべてがカーネルによってクローズされる。

#### 1.5.6.4 ファイル名変更とファイル削除

ファイルの名前を変えたり、ファイルを削除するとき、プロセスはそのファイルをオープンする必要はない。  
実際、このような操作は対象ファイルの中身ではなく、1つか2つのディレクトリの中身に対する操作である。  

例)  
ファイルリンクの名前を変更する
```
res = rename(oldpath, newpath);
```

ファイルのリンク数を1減らし、ディレクトリ内の対応するエントリを削除する。
（実際にはリンクカウントが0になったときにファイルが削除される）
```
res = ulink(pathname);
```

## 1.6 UNIX カーネルの概要

UNIXカーネルは、アプリケーションが動作する実行環境を提供する。
そのためカーネルは一連のサービスとそれに対応するインタフェースを実装しなければならない。  
アプリケーションはハードウェア資源を直接操作することはなく、インタフェースを利用する。

### 1.6.1 プロセス/カーネルモデル

CPUはユーザモードかカーネルモードで動作する。
実際には、CPUには2つ以上の実行状態を持てるものもあり、Intel 80x86プロセッサは4つの状態を持てる。  
しかし全ての標準的なUNIXカーネルは2つのモードだけを利用している。

カーネル自身はプロセスではなく、プロセスのマネージャ。  
プロセス/カーネルモデルでは、カーネルの差０ビスを必要とするプロセスは、システムコールを使用することが前提となっている。  
システムコールはプロセスからの要求を一意に決める引き数群を設定する。  
その後、ユーザモードからカーネルモードへ行こうし、ハードウェア依存のCPU命令を実行する

UNIXシステムには、ユーザプロセスの他にも、カーネルスレッド(kernel thread)と呼ばれる特権プロセスがいくつかある。  
その特徴は以下。
- カーネルアドレス空間に置いて、カーネルモードで動作する
- ユーザとのやり取りはないため、端末デバイスを必要としない
- システムの起動時に生成されるのが普通で、システムがシャットダウンされるまで動作し続ける

単一プロセッサシステムでは、任意の時点において1つのプロセスだけが実行されている。  
カーネルモードであれば、プロセッサは何らかのカーネルルーチンをじっこうしている。  

図1-2(p23)にユーザモード・カーネルモードが切り替わる様子

UNIXカーネルはシステムコールを処理するだけではない。  
実際、カーネルルーチンは以下に示す様々な方法によって駆動される。

- プロセスによるシステムコールの発行
- プロセスを実行中のCPUによる例外信号の発生
  - 例外とは命令が無効などの何らかの異常な状態のこと
  - 原因となったプロセスに変わってカーネルが例外を処理する
- 周辺デバイスからのCPUへの割り込み信号(interrupt signal)の発行
  - データが届いた等、CPUの注意を換気するためや、状態の変更、I/O操作の完了などの事象を知らせるためのもの
  - 書く割り込み信号は、割り込みハンドラ(interrupt handler)に処理される
  - 周辺デバイスはCPUとは非同期的に動作するので、割り込みは予測不可能な時点で発生する
- カーネルスレッドの実行
  - カーネルスレッドはカーネルモードで実行されるため、対応するプログラムはカーネルの一部とみなされる

### 1.6.2 プロセスの実装
カーネルによるプロセスの管理を実現するため、各プロセスはプロセスディスクリプタ(process discriptor)によって表される。  
プロセスディスクリプタにはプロセスの現在の状態についての情報が含まれている。

カーネルはプロセスの実行を停止する際、その時点でのプロセッサレジスタの内容をプロセスディスクリプタの中に退避する。  
- プログラムカウンタ(PC)レジスタとスタックポインタ(SP)レジスタ
- 汎用レジスタ
- 浮動小数点レジスタ
- プロセッサ制御レジスタ（プロセッサステータスワード、CPUの状態についての情報）
- メモリ管理レジスタ（プロセスが使用するRAMの管理）

カーネルはプロセスの実行再開を決めると、対比しておいたCPUレジスタを復旧するために、対応するプロセスディスクリプタのメンバを使用する。  


### 1.6.3 再入可能なカーネル
全てのUNIXカーネルは再入可能（リエントラント）。  
つまり同時に複数のプロセスをカーネルモードで実行することがある。  

再入可能性を実現する方法の1つはローカルな変数を変更し、グローバルな変数を変更しないような関数を書くこと。  
このような再入可能関数だけで、再入可能なカーネルが実現されているわけではない。（一部のリアルタイムカーネルはこの方法で実装されている）  
カーネルは再入不可能な関数を実行する場合、ロック機構を使って、その関数を実行するプロセスがその時点で1つだけであることを保証する。  

再入可能なカーネルでは、カーネルモードで実行中のプロセスであっても、現在実行中のプロセスを一時停止することが出来る。(性能のために非常に重要)

カーネルの再入可能性と、カーネルの構造に及ぼす影響について注目してみる。  
カーネル実行パス(kernel control path)とは、システムコール、例外、割り込みを処理するためにカーネルに酔って実行される命令シーケンスのこと。

- ユーザモードで実行中のプロセスに酔ってシステムコールが発行されたが、対応するカーネル実行パスではその要求を即座に完了できないことが確認された場合
  - 新しく実行するプロセスを選ぶためにスケジューラを呼び出す。
  - その結果、プロセス切り替えが行われる。
  - 最初のカーネルパスは未完了のまま残され、CPUは別のカーネル実行パスの実行を再開する。
  - この場合、それぞれのプロセスに対応した異なる2つの実行パスが実行される

- カーネルが実行パスを実行中、CPUが例外を検出した場合
  - 最初の実行パスは一時停止され、CPUは対応する適切な処理を開始する。
  - 例外に対する処理が終了すると、細書の実行パスを再開することが出来る。

- 割り込み許可の状態でCPUがカーネル実行パスを実行中に、ハードウェア割り込みが発生した場合
  - CPUは割り込みを処理するために、別のカーネル実行パスの処理を開始する
  - 細書のカーネル実行パスは、割り込みハンドラが実行を終了すると、再開される。
  - この場合、2つのカーネル実行パスは、同じプロセスの実行コンテキスト内で実行される。
  - プロセスの経過システム時間はその合計とみなされる。
  - ただし、割り込みハンドラは、必ずしもそのプロセスのための処理を行っているとは限らない


- カーネル内プリエンプと可能な箇所で、CPUに割り込みが発生し、高い実行優先度のプロセスが実行可能になったとき
  - 細書のカーネル実行パスから、より高い実行優先度のプロセスのカーネル実行パスを再開する
  - これはカーネル内プリエンプション可能となるように、カーネルをコンパイルしている場合にのみ起こる

割り込みがない場合と、ある場合のカーネル実行パスの例を図1-3(p.26)に示す
- プロセスをユーザモードで実行中(User)
- 例外またはシステムコールの処理を実行中(Excp)
- 割り込み処理を実行中(Intr)


### 1.6.4 プロセスアドレス空間
プロセスは、それぞれの固有うなアドレス空間において実行される。  
ユーザモードとカーネルモードでそれぞれ固有のスタックを使う。  

各プロセスが固有なアドレス空間にアクセスしているかのように見えていても、固有のアドレス空間の一部が複数のプロセスによって共有されている場合もある。  
この共有は、プロセスに酔って明示的に要求されることもあれば、メモリ使用量を減らすためにカーネルが自動的に行うこともある。    
同時に複数のユーザに酔って同じプログラム（例えばエディタ）を必要とする場合、そのプログラムがメモリに読み込まれるのは一度だけ。  
プログラム中の命令は必要としている全てのユーザで共有することが出来る。  
もちろんユーザごとに別々のデータになるため、データは共有してはいけない。  
この種のアドレス空間の共有は、メモリの節約のためにカーネルが自動的におこなう。  

プロセウはプロセス間通信の一種を使ってアドレス空間の一部wお共有することも出来る。
SystemVで道有され、Linuxでも提供されている「共有メモリ」手法が利用されている。
更に、Linuxではmmap()システムコールを備えている。  
このシステムコールは、ファイルブロック型デバイス内の情報をプロセスアドレス空間の一部へマッピングするもの。  
メモリマッピングは、通常のread/writeシステムコールの代わりとして、データ転送に使用することも出来る。  
複数のプロセスに酔って共有されている同じファイルのメモリマッピングは、共有している各プロセスそれぞれのアドレス空間内に割り当てられる。  


### 1.6.5 同期とクリティカル区間

 再入可能なカーネルを実装するには同期機構が必要。  
 あるカーネル実行パスがカーネルデータを利用している最中に一時停止させられると、整合性の保たれた状態に戻るまで、他のカーネル実行パスが同じカーネルデータを使用することは許されない。  

 何らかの計算の結果が2つ以上のプロセスのスケジューリングに依存する場合、そのコードは正しくない。
 これを競合状態(race condition)にあるという。

 一般的にグローバル変数への安全なアクセスは、アトミックな操作(atomic operation(不可分な操作))を行うことによって保証される。  
 アトミックな操作だけでは全てに対応することは出来ない。  
 例えば、連結リストから1つの要素を削除する場合、1回の操作で行うことは出来ない。
 このような実行を開始したプロセスが、他のプロセスが同じ部分を実行する前にその処理を狩猟する必要があるコード領域のことをクリティカル区間(critical region)という。  


 これはカーネル実行パスに限られた問題ではなく、データを共有しているプロセス間にも生じる問題。
同期の手法は様々なものが採用されていて、次の節ではカーネル実行パスが互いに同期をとる方法に注目する。


#### 1.6.5.1 カーネル内プリエンプトの禁止

同期の問題に対して単純さを極めた解法を提供するために、幾つかの伝統的なUNIXカーネルはプリエンプト不可になっている。  
つまりプロセスがカーネルモードで実行中の時は、任意に一時停止させられたり、他のプロセスに切り替えられたりすることはない。  
カーネルモードのプロセスは自発的にCPUを明け渡すことも出来る。  
この場合、変更された可能性のあるデータすべての値を再確認する必要がある。  

プリエンプと可能なカーネルの同期機構として、カーネル内プリエンプとの禁止がある。  
クリティカル区間を実行する前にカーネル内プリ円ぷとを禁止し、クリティカル区間を抜けた時にカーネル内プリ円ぷとを許可する。

しかし、プリ円ぷとを禁止するという解決法は、マルチプロセッサシステムでは不十分。  
異なるCPU上で実行されている2つのカーネル実行パスが同じデータに同時にアクセスする可能性があるため。  



#### 1.6.5.2 割り込みの禁止

単一プロセッサシステム用のもう一つの同期機構として、クリティカル区間に入る前に全てのハードウェア割り込みを禁止し、クリティカル区間を出た直後に再び割り込みを許可するという方法がある。  
この方法は単純である一方で、クリティカル区間が広範囲に渡る場合、パフォーマンス上の問題がある。
さらに、マルチプロセッサシステムではこの方法では不十分で、他の同期機構を用いる必要がある。


#### 1.6.5.3 セマフォ

単一プロセッサシステムとマルチプロセッサシステムの両方において、効果的であり、広く使用されている機構としてセマフォ(semaphore)がある。  
セマフォとは単にデータに関連付けたカウンタ。  
カーネルスレッドがデータにアクセスしようとする前にかならず確認される。  

セマフォは、次の要素からなるオブジェクト
- 整数型変数
- 待ち状態にあるプロセスのリスト
- 2つのアトミックなメソッド(down()とup())

セマフォの値をdown()で1減算、up()で1加算する。  
セマフォの新しい値が0より大きい場合には、セマフォリスト中の1つ以上のプロセスを再び実行可能状態にする。  
保護されるべきデータはそれぞれセマフォを持ち、その値を1に初期化している。  
カーネルカーネル実行パスは、データへのアクセスが必要になると、適切なセマフォに対して、down()メソッドを実行する。新しいセマフォの値が婦でなければ、データへのアクセスが許可される。府の場合は、カーネル実行パスを実行しているプロセスがセマフォリストに付け加えられ、実行を止められる。


#### 1.6.5.4 スピンロック

マルチプロセッサシステムに置いては、同期問題の解決法としてセマフォが必ずしも最適であるとは限らない。  
カーネルデータの幾つかは、異なるCPU上で実行中のか＝ネル実行パスによる同時アクセスから保護される必要がある。  
この場合、短い時間でデータ更新ができるときは、セマフォは非常に効率が悪くなることがある。  
このような場合では、マルチプロセッサオペレーティングシステムでは、スピンロック(spin lock)が利用される。  
スピンロックはセマフォとにているが、プロセスリストを持っていない。他のプロセスによって、ロックされていることを検出したプロセスは、ロックが解除されるまで短いループを繰り返し、「スピン」する。  
当然、スピンロックは単一プロセッサ環境では役に立たない。


#### 1.6.5.5 デッドロックの回避
他のカーネル実行パスと同期をとるプロセスやカーネル内の実行パスは、容易にデッドロック(deadlock)状態に陥る可能性がある。  
デッドロックは使用するカーネルのロック数が多い時に問題になりやすい。  
その場合、カーネル実行パスを切り替えながら実行する全ての場合において、全くデッドロック状態が発生しないことを保証するのはかなり難しい。  
Linuxをはじめとする行くるかのOSでは、ロック要求をある決まった順序に揃えることに酔って、この問題を回避している。


### 1.6.6 シグナルとプロセス間通信

UNIXのシグナルは、システム事象をプロセスに通知する仕組みを提供する。  
各事象にはそれぞれシグナル番号があり、通常はSIGTERMのようなマクロ名によって参照される。  
システムの事象には以下の２種類がある。
- 非同期通知
  - ユーザは割り込みキーコード（通常はCTRL+C）を端末で入力することにより、割り込み信号SIGINTをフォアグラウンドプロセスに送ることが出来る
- 同期通知
  - プロセスが無効なアドレスのメモリ位置にアクセスしようとした場合、カーネルはプロセスに対し、シグナルSIGSEGVを送る

POSIX標準では、約20のシグナルが定義されている。  
そのうち2つは、ユーザが定義することができ、ユーザモードのプロセス間での通信と同期のための基本機構として使用することが出来る。  

プロセスがシグナルの受信時の対応を決定していない場合、カーネルはシグナル番号ごとに決められた標準初期設定の動作(default action)を実行する。  
これには以下の5つがある。

- プロセスを終了する
- 実行コンテキストとアドレス空間の内容をファイルに書き込み、プロセスを終了する
- シグナルを無視する
- プロセスを停止する
- プロセスが停止していた場合、実行を再開する

POSIXでは、プロセスが一時的にシグナルをブロックすることを許している。  
一方で、SIGKILL, SIGSTOPシグナルに対しては、プロセスが直接処理することも無視することも出来ない。  

AT&TのUnix System Vでは、ユーザモードのプロセス間通信として、シグナルとは異なる機構が導入された。  
これらは、セマフォ、メッセージキュー、共有メモリと呼ばれているもので、多くのUNIXカーネルに採用されている。  
これらはまとめて、System V IPCとして知られている。  

カーネルはこれらの機構をIPC資源（IPC resource）として実装している。  
プロセスは、shmget(), semget(), msgget()といったシステムコールを呼び出すことにより、資源を獲得する。  
ファイルと同様に、IPC資源も永続的。資源を生成したプロセス化、現在の所有者、あるいはスーパーユーザのプロセスによって、明示的に割当が解除される必要がある。  

- semaphore
  - セマフォは、ユーザモードのプロセスのために用意されている点を除けば、1.6.5で説明したセマフォと同様。
- message queue
  - メッセージキューは、msgsnd(), msgrcv()システムコールを利用することによってプロセスがメッセージをやり取りできるようにする
  - msgsnd()は、特定のメッセージキューにメッセージを挿入し、msgrcv()は底からメッセージを取り出す
  - POSIX標準(IEEE std 1003.1-2001)は、メッセージキュー型のIPC機構を定めている。
    - これをPOSIXメッセージキューという
  - System Vのメッセージキューとよく似ているが、より単純なファイルベースのアプリケーションインタフェースを提供する
- shared memory
  - 共有メモリは、データをやり取りしたり共有したりするための最も高速な方法をプロセスに提供するためのもの
  - プロセスはshmget()システムコールを発行して、要求された大きさの新しい共有メモリの作成から始める
  - IPC資源の識別子を獲得した後、プロセスはshmat()システムコールを呼び出す
  - このシステムコールはプロセスアドレス空間内の新しい領域の先頭アドレスを返す。
  - アドレス空間から共有メモリを解放したい場合、プロセスはSHMAT()システムコールを呼び出す
  - 共有メモリの実装は、カーネルがプロセスのアドレス空間を実装している方法によって異なる


### 1.6.7 プロセス管理
UNIXでは、プロセスと実行中のプログラムとを明確に区別している。  
新しいプロセスの生成と終了のために、それぞれfork(),\_exit()システムコールを使用し、新しいプログラムを読み込むためにはexec()系のシステムコールを呼び出す。  
exec()系のシステムコールが実行されると、プロセスは読み込まれたプログラムを含む、全く新しいアドレス空間をしようして実行を再開する。  

fork()を呼び出したプロセスを親プロセス、新しいプロセスを子プロセスと呼ぶ。  
親プロセスと子プロセスはお互いを見つけることが出来る。  
プロセスを表現するデータに、直属の親へのポインタと直下のすべての子へのポインタが含まれている。

fork()を単純に実装してしまうと、親プロセスのデータとコードを全て複製して子プロセスに割り当てる必要があり、時間がかかってしまう。  
ハードウェアのページング回路が使用できる現在のカーネルでは、コピーオンライトという手法が採用されている。  
これは、ページの複製を可能な限り（つまり、親過去のどちらかがページに書き込む必要が生じるまで）遅延させるもの。  
Linuxにおけるこの手法の実装は9.4.4で説明する。

\_exit()システムコールはプロセスを終了させる。  
カーネルはこのシステムコールを処理するために、プロセスが有している資源を開放し、親プロセスにSIGCHLDシグナル（標準設定動作では無視される）を送る

#### 1.6.7.1 ゾンビプロセス

プロセスはwait4()システムコールによって、自分の子プロセスの1つが終了するまで待つことが出来る。この戻り値は終了した子プロセスのプロセスID。  
カーネルはこのシステムコールをハッ処理する差異、子プロセスがすでに修了しているかどうかを確認する。  
ゾンビ(zombie)は、プロセスの特殊な状態であり、終了したプロセスを表すために導入された。  
プロセスは親プロセスがwait4()システムコールを発行するまでは、この状態になっている。  
システムコールサービスルーチンは、プロセスディスクリプタのメンバから資源の使用状況についてのデータを取り出す。  
一旦データが収集されたら、プロセスディスクリプタは解放されても構わない。
wait4()システムコールが実行された際に、すでに終了した子プロセスが存在しない場合、カーネルは通常、1つの子プロセスが終了するまでプロセスを待ち状態にする。

多くのカーネルではwaitpid()システムコールも実装されている。  
これにより、プロセスは特定の子プロセスを待つことができるようになる。（他の種類のwait4()システムコールも実装されている。）  

例えば、コマンドシェルなどでは、実行するプロセスはバックグラウンドで実行される。コマンドシェルを終了すると、コマンドシェルを実行していたプロセスは終了されるが、このプロセスが作成した子プロセスは実行を続けている。  
この問題を解決するために、プロセスを終了する際、その子プロセスはinitというシステムプロセスの子プロセスになる。  
このinitプロセスが全ての子プロセスの実行を監視し、定期的にwait4()システムコールを発行することで、結果的に迷子状態のすべてのゾンビプロセスがなくなる。
こういった実装にすることによって、親プロセスがwait4()を実行せずに終了してしまった場合に、メモリ領域を無駄にする問題が解消されている。


#### 1.6.7.2 プロセスグループとログインセッション

最近のUNIXオペレーティングシステムでは、「ジョブ」という抽象概念を表すために、プロセスグループ(process group)という考え方を導入している。  
```
$ ls | sort | more
```
例えば、上記のようなコマンドラインを実行する場合、プロセスグループを扱えるbashのようなシェルでは、ls, sort, moreに対応する3つのプロセス用の新しいグループを生成する。  
このようにして、シェルは、3つのプロセスをあたかもそれらが1つの存在（正確にはジョブ）であるかのように扱う。  

- プロセスグループ
  - 各プロセスディスクリプタには、プロセスグループID(process group ID)メンバがある
  - 各プロセスグループはグループリーダ(group leader)を持つことが出来る
  - グループリーダはプロセスグループIDと同じPIDを持つプロセス
  - 新しく生成されたプロセスは、最初は親のプロセスグループに入れられる
- ログインセッション(login session)
  - ログインセッションには、特定の端末上でセッションを開始したプロセス（通常はユーザ用に生成さた最初のコマンドシェルプロセス）の子孫のプロセスが全て含まれている
  - 同じプロセスグループの中のプロセスは全て、同じログインセッションの中に含まれなければならない
  - ログインセッションには、動作中のプロセスグループが同時に複数存在することがある
  - そのうち1つのプロセスぐる＝ぷが必ずフォアグラウンドとなり、端末へのアクセスが許可されている
  - 他の動作中のプロセスグループはバックグラウンドになっている
  - バックグラウンドプロセスが端末への亜k樹セスを行おうとすると、端末はSIGTTINまたはSIGTTOUシグナルを受け取る
  - 多くのコマンドシェルでは、プロセスグループをバックグラウンドやフォアグラウンドにするための内部コマンドbgとfgが利用できる


### 1.6.8 メモリ管理
メモリ管理は、UNIXカーネルにおける最も複雑な動作となっている。  
本書では、Linuxのメモリ管理方法についての説明だけに1/3以上を割いている。  
ここでは、メモリ管理に関する主な内容について説明する。

#### 1.6.8.1 仮想記憶

最近の全てのUNIXシステムでは、仮想記憶(virtual memory)と呼ばれる、有益な抽象概念を提供している。  
仮想記憶は、アプリケーション化あrのメモリ要求とハードウェアのメモリ管理回路(Memory Management Unit:以下 MMU)との間の論理的なレイヤとしての役割を持つ。  
仮想記憶には、多くの目的と利点がある。

- 複数のプロセスを同時に実行できる
- 利用可能な物理メモリの量よりも多くのメモリを要求するアプリケーションも動作させることが出来る
- プロセスは、部分的にしかコードがメモリ内に読み込まれていないプログラムでも、実行することが出来る
- 各プロセスは、利用可能な物理メモリの一部分だけにアクセスが許される
- プロセスあ、同一のライブラリやプログラムのイメージを共有することが出来る
- プログラムを再配置可能(relocatable)にできる（つまり、物理メモリ内の何処にでも置くことができるようになる）
- プログラマは、物理メモリの構成について配慮せずに済むため、マシンに依存しないコードを書くことが出来る

仮想記憶サブシステムで大切なのは、仮想アドレス空間(virtual address space)という概念。  
プロセスが参照するときに指定するメモリアドレスは、物理的なメモリアドレスとは異なる。  
プロセスが仮想アドレスを使用する時、カーネルとMMUが連携して、要求されたメモリの実際の物理的な位置を割り出す。  

最近のCPUには、自動的に仮想アドレスを物理アドレスに変換するハードウェア回路が内蔵されている。  
これを利用するため、利用可能なRAMは4KBまたは8KBなどのおおきさのページフレーム(page frame)に分割され、仮想アドレスと物理アドレスとを対応させるためにページテーブルが導入される。  
こうした回路により、メモリの割当は、より単純になる。  
連続した仮想アドレスのブロック要求をされても、連続していない物理アドレスを持つページうレームのグループを割り当てることで対処できるようになるため。



#### 1.6.8.2 ランダムアクセスメモリの使用

すべてのUNIX OSでは、RAMを2つの部分に明確に分けている。  
まず、カーネルイメージ（つまり、カーネルコードとカーネルの静的データ）を保存しておく専用の数MBの領域がある。  
そして、RAMの残りの部分は通常、仮想記憶システムによってかんりされ、次の3つの処理につかわれる。
- バッファやディスクリプタなどの動的なカーネルデータに関する、カーネルからの要求を満たす
- 一般的なメモリ領域とファイルのメモリマッピングに関する、プロセスからの要求を満たす
- キャッシュとして利用し、ディスクなどバッファリングされるデバイスの性能を引き出す

メモリは有限なので、利用できるメモリが何らかの致命的なしきい値に達してしまし、さらなるメモリを解放するために、ページフレーム回収アルゴリズムが呼び出される場合、解放するのに最も適したアルゴリズムは何なのだろうか。  
これは17章で説明するように、明確な答えはなく、理論的な根拠も殆ど無い。唯一利用可能な解決法は、慎重に調整された経験則に基づくアルゴリズムのみとなっている。

仮想記憶システムが解決しなければならない大きな問題の１つに、メモリの断片化(memory fragmentation)がある。  
理想的には、メモリの要求に失敗するのは、空きページフレームの数が少なすぎるときに限られるべき。  
カーネルはブル知的に連続したメモリ領域の使用を強制されることがある。  
そのため、利用可能なメモリが十分にあったとしても、1つの連続した部分として利用できなければ、メモリの要求に失敗する可能性がある。


#### 1.6.8.3 カーネルメモリアロケータ

カーネルメモリアロケータ(Kernel Memory Allocator以下KMA)は、システムのあちこちから出されるメモリ領域に関する要求を満たすためのサブシステム。  
以下は、優れたKMAが持つべき特徴。
- 高速性
- ムダにするメモリの量を最小限に抑えること
- メモリの断片化の問題を減らすこと
- ページフレームを獲得したり、解放したりするために、他のメモリ管理サブシステムと協力すること

数種類のKMAが提案されているが、以下の様な様々なアルゴリズムに基づいている
- 資源マップアロケータ
- 2のべき乗アロケータ
- McKusick-Karelsアロケータ
- バディシステム
- Machのゾーンアロケータ
- Dynixアロケータ
- Solarisのスラブアロケータ

8章で説明しているように、LinuxのKMAはバディシステムのスラブアロケータを使用している。



#### 1.6.8.4 プロセスの仮想アドレス空間の取り扱い

プロセスのアドレス空間には、プロセスが参照可能な全ての仮想アドレスが含まれている。  
通常、カーネルは、プロセスの仮想アドレス空間をメモリリージョンディスクリプタ(memory region descriptor)のリストとして保存している。  
例えば、プロセスが、exec()系のシステムコール経由で何らかのプログラムの実行を開始すると、カーネルはそのプロセスに以下のようなメモリリージョンから形成される仮想アドレス空間を割り当てる。
- プログラムの実行可能なコード
- プログラムの初期値ありのデータ
- プログラムの初期値なしのデータ
- 最初のプログラムスタック（ユーザモードのスタック）
- 必要となる共有ライブラリの実行コードとデータ
- ヒープ（プログラムに酔って動的に要求されるメモリ）

最近の全てのUNIX OSでは、デマンドページング(demand paging)と呼ばれるメモリ割り当ての方式が採用されている。  
デマンドページングでは、プロセスは自分のページを物理メモリには1つも持たない状態で、プログラムの実行を開始することが出来る。  
プロセスが存在しないページにアクセスしようとすると、MMUが例外を発生させる。  
そうすると、例外ハンドラが対象のメモリリージョンを探しだし、空きページを割当、適切なデータでそのページを初期化する。  
同様に、プロセスが、malloc(), またはmalloc()が内部的に呼び出すbrk()システムコールを使用してメモリを動的に要求する際、カーネルは物理的なメモリ領域の確保は行わずに、単にプロセスのヒープ領域の大きさを更新するだけ。  
ページフレームがプロセスに割り当てられるのは、仮想アドレスを参照しようとして例外が発生した時だけ。

先に述べたコピーオンライトなどの効率的な手法は、仮想アドレス空間でも利用できる。  
たとえば、新しいプロセスが生成された際、カーネルは単に親プロセスのページフレームを子プロセスのアドレス空間に割り当てるだけ。  
ただし、読み取り専用の印をつける。  
親または子プロセスがページの内容を更新しようとすると、その時点で例外が発生する。  例外ハンドラは例外を発生させたプロセスんい新しいページフレームを割り当て、元のページで内容を初期化する。


#### 1.6.8.5 キャッシュ
もう存在しないプロセスが読み書きしたデータが、別のプロセスに再利用される可能性が高いという事実にもとづき、ディスクから読み込んだブロックに対応するディスクバッファをRAMに残しておくことにより、ディスクへの書き込みを出来るだけ先延ばしする。  
プロセスがディスクアクセスを要求すると、カーネルはキャッシュ上にデータがないか調べる。  
見つかれば（キャッシュにヒット）、カーネルはディスクにアクセスすることなく、プロセスの要求に応えることが出来る。

sync()システムコールは、全ての「汚れたバッファ」（つまり、対応するディスクブロックと内容が異なるような全てのバッファ）をディスクに書き込むことで、強制的にディスクとの同期を取る。  
データの紛失を避けるため、全てのOSでは汚れたバッファを定期的にディスクに書き戻すようにしている。



### 1.6.9 デバイスドライバ

カーネルはデバイスドライバ(device driver)を通じて、I/Oデバイスを操作する。  
デバイスドライバはカーネルの一部であり、ハードディスク、キーボード、マウス、モニタ、ネットワークインタフェース、SCSIバスに接続されたデバイスと言った、1つ以上のデバイスの制御を行うデータ構造と関数から構成されている。  
各ドライバは、特定のインタフェースを通じてカーネルの他の部分と（他のドライバとも）やり取りする。  
この方法には、以下の様な利点がある。
- デバイス特有のコードを特定のモジュールとしてカプセル化することが出来る
- カーネルソースコードを知らないベンダでも、新しいデバイスを追加することが出来る
  - 知らなければならないのは、インタフェースの使用だけである
- カーネルは、全てのデバイスを一華院した方法で扱い、同じインタフェースを通じてアクセスする
- システムの再起動が必要なく、カーネル内んい動的に組み込み可能なモジュールとして、デバイスドライバを書くことが出来る
  - 飛鳥亡くなったら動的に削除することが出来、RAMを効率的に使用できる

図1-4はデバイスドライバがどのようにカーネルのほかの部分やプロセスと相互接続しているのかを示している

図1-4(p.38)

幾つかのユーザプログラム(P)がハードウェアを操作しようとしている  
その倍、通常のファイル関連のシステムコールと、通例、/devディレクトリにあるデバイスファイルを使って、カーネルに要求を出す。  
（実は、デバイスファイルは、デバイスドライバのインタフェースのユーザに見えている部分なのだ。）  
各デバイスファイルは特定のデバイスドライバに対応している。  
デバイスドライバは、ハードウェアに要求された処理を行わせるため、カーネルによって呼び出される。


.
