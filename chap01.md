# chapter-01 概要

Linuxは1991年から最初はIntel 80386プロセッサベースのIBM PC互換機用のOSとして、Linus Torvaldsにより開発された。  
Linuxの魅力の１つは商用ではないことで、GNU一般公衆利用許諾契約書(GNU General Public License:以降GPL)に基づいて公開されている。  
そのため、誰でも自由に調べたり、ダウンロードしたりできる。  

## 1.1 LinuxとほかのUNIX系カーネル

市場にはさまざまなUNIX系システムが出回っている  
商用UNIXはすべて、IEEEのPOSIX(Portable Operating Systems based on Unix)やX/OpenのCAE(Common Applications Environment)といった一般的な標準規格に従う傾向がある。  
現在の標準規格では、API(Application Programming Interface)、つまり、ユーザプログラムが実行される環境のみが規定されている  
共通のユーザインタフェースを定義するため、UNIX系カーネルでは多くの場合基本的な設計思想や機能が共有されている。  
この点はLinuxは他のUNIX系OSと類似しているので、Linuxで学んだことはUNIXの理解にも役立つ。

Linuxカーネルのバージョン2.6はIEEE POSIX標準への準拠を目指しているので、既存のUNIXプログラムの殆どがLinuxシステム上でコンパイルして実行できるようになる。  
更に、仮想ファイルシステム、軽量プロセス、UNIXシグナル、SVR4プロセス間通信、対象型マルチプロセッサ(Symmetric MultiProcessor(以下SMP))システムが扱えるなど、近代的なUNIX OSの持つ機能をLinuxは全て備えている。  

Linus Torvaldsはカーネルを書き始める時に、Maurice Bach著「The Design of the Unix Operating System」のようなUNIXの古典的な本を参考にしたため、UNIXの設計方針に偏っているところがある。
以下にLinuxと他の代表的な商用UNIXカーネルを比較、評価した結果を挙げる。

- モノリシックカーネル(一枚岩)
  - Linuxカーンるはおおきく複雑で自己完結的なプログラム
  - UNIX系OSの殆どもモノリシック
  - モノリシックと相対する構造をもつのは、Mac OS XとGNU Hurd OSが有名でこれらは、マイクロカーネルという方式をとっている
- 伝統的なUNIXカーネルのコンパイルとリンクは静的
  - 近代的なカーネルならば、たいていカーネルコードの一部を動的に組み込んだり、削除したりできる
  - これはモジュールと呼ばれ、典型的な例はデバイスドライバ
  - Linuxのモジュール支援機構は非常にす売れていて、必要に応じてこれらを自動的に組み込んだり削除したりできる
- カーネルスレッド
  - 近代的なUNIXカーネルは、カーネルスレッドの集合体として構成されている
  - カーネルスレッドとは、独立してスケジューリングが可能な実行コンテキスト
  - カーネルスレッドには、ユーザプログラムに対応するものもあれば、カーネルの関数に対応するだけのものもある
  - カーネルスレッドは共通のアドレス空間で実行されるので、プロセス間のコンテキスト切り替えよりずっと効率が良いことが多い
  - Linuxでは、カーネルスレッドを、定期的にいくつかのカーネル関数を実行するという限定された方法でしか使用していない
- マルチスレッドアプリケーション支援
  - マルチスレッドなアプリケーションとは、アプリケーションのデータのかなりの部分を共有し、比較的独立した多くの処理の流れを取り扱えるように設計されたユーザプログラムのこと
  - マルチスレッドなユーザアプリケーションは多くの軽量プロセス(LightWeight Process、以下LWP)から構成される場合もある
  - Linuxでは、独自のLWPを定義している
    - 基本的な実行コンテキスト(プロセスと同じ)とみなされ
    - 標準的ではないclone()というシステムコールで処理される
- マルチプロセッサ支援
  - SMP機能を提供し、NUMAのような異なるメモリモデルのものも扱える
- ファイルシステム
  - Linuxの標準ファイルシステムに多くの機能が追加された
  - Ext2, Ext3, ReiserFS, JFS, XFSなど
- STREAMS
  - SVR4で導入されているSTREAMS I/Oサブシステムは、最近ではほとんどのUNIXカーネルに用意されるが、Linuxにこれに類似するものはない

以上のような特徴の他に、商用のUNIXと比べて以下のような利点がある

- Linuxは無料である
- Linuxでは全ての構成部分をカスタマイズできる
- Linuxはローエンドで安価なハードウェアプラットフォーム上でも動作する
- Linuxは強力である
- Linuxカーネル開発者は卓越したプログラマである
- Linuxカーネルは非常に小さくすることができる
- Linuxは多くの一般的なOSとの互換性が高い
- Linuxには優れたサポートがある

## 1.2 ハードウェア依存

Linuxではソースコードのハードウェアに依存する部分と非依存の部分を明確に区別している。  
そのため、archディレクトリとincludeディレクトリの両方に23種類のハードウェアプラットフォームに対応するサブディレクトリをおいている。

プラットフォームの標準名（ここでは代表的なのいくつか）
- arm, arm26
- i386
- MIPS
- x86_64

## 1.3 Linuxのバージョン

Linuxカーネル2.5までは単純な番号体型でバージョンをつけていた。  
ピリオドによって3つに区切られた、最初の2つがバージョンを特定し、３つめがリリース番号  
2.5までは2つ目の数字が偶数であれば安定版、奇数であれば開発版を意味していたが、2.6以降はそうではない。


## 1.4 オペレーティングシステムの基本概念

この本では多くの場合は「オペレーティングシステム」と「カーネル」を同義として扱う。  
オペレーティングシステムは、2つの重要な役割がある
- 低水準のプログラマブルなハードウェアを制御する
- コンピュータシステム上で実行するアプリケーションに実行環境を提供する

OSの中にはWindowsのようにユーザプログラムにハードウェアを直接操作することを認めているものもある。  
一方、UNIX系のOSではユーザプログラムにはこれらを隠蔽している

近代的なOSではこの仕組みを実現するために、ハードウェアに備わっている特定の機能に依存している。  
具体的には、ハードウェアはCPUに少なくとも2つの異なる実行モードを用意している  
それぞれをユーザモードとカーネルモードと呼ぶ  
以降のこの章ではこれらの基本的な概念を紹介し、2章以降ではLinuxカーネル内部機構を理解するための内容が続く。

### 1.4.1 マルチユーザシステム

マルチユーザシステムとは2人以上のユーザが様々なアプリケーションを並行して独立に実行することが可能なコンピュータ  
- 並行に：複数のアプリケーションが同時に動作状態になり、CPU、メモリ、ディスクなどの様々な資源を取り合うことができる
- 独立に：他のユーザのアプリケーションの動作とは無関係に処理を実行できる

マルチオペレーティングシステムには以下のような機能が必要
- ユーザIDを確認する認証機構
- 同じシステム上で他のアプリケーションの動きを止めてしまう可能性のあるバグをもつユーザプログラムに対する保護機構
- 悪意のあるユーザプログラムに対するする保護機構
- 各ユーザに割り当てる資源の量を制限するアカウンティング機構

保護機構の安全性を保証するために、オペレーティングシステムはハードウェア(CPUの特権モード)による保護を利用する必要がある。


### 1.4.2 ユーザとグループ

マルチユーザシステムでは、マシン上に各ユーザの個人領域がある。
ユーザは全て、ユーザID(UID)と呼ばれる一意の番号によって識別される。  
ユーザがセッションを開始するには、ログイン名とパスワードが要求される。
他のユーザとデータを共有するために各ユーザは１つ以上のユーザグループに所属する。  
グループはユーザグループID(GID)によって識別される。  
全てのUNIX系オペレーティングシステムには、ルート(スーパユーザ、スーパバイザ)と呼ばれるシステムの管理用ユーザがある。  
ルートユーザはシステムの全てのユーザプログラムの実行を操作することができる。


### 1.4.3 プロセス

プロセスは「実行中のプログラムのインスタンス」または、動作中のプログラムの「実行コンテキスト」と定義できる。  
プロセスは1つのアドレス空間において、命令の並び（命令シーケンス）を1つ以上実行する。  
マルチユーザシステムでは、複数のプロセスが同時に動作状態になり、システム資源（おもにCPU）を取り合うという実行環境を提供しなければならない。  
複数のプロセスが同時に動作状態になることが可能なシステムのことを、「マルチプログラミングシステム」または「マルチプロセッシングシステム」という。  

一般的にCPUの数は限られているので、同時に実行できるのは数プロセスだけ。  
OSのスケジューラが実行するプロセスを選択する。  
マルチユーザシステムのプロセスは「プリエンプト可能」でなければならない。つまり、OSが各プロセスがCPUを獲得していた時間を管理し、定期的にスケジューラを作動する。  
UNIX系OSでは「プロセス/カーネル」モデルが採用されていて、各プロセスは自分がマシン上の唯一のプロセスであり、OSのサービスを専有していると錯覚している。  

### 1.4.4 カーネルアーキテクチャ

UNIXカーネルの殆どはモノリシック。カーネル内の各レイヤはカーネルプログラム全体へと統合され、カレントプロセスの代わりにカーネルモードで動作する。  
対象的に、マイクロカーネル方式のOSでは、カーネルに要求される機能はわずかである。  
一般的には、数種類の動機プリミティブ、単純なスケジューラ、プロセス間通信機構などがある。  
その他のOSレイヤの機能、メモリアロケータ、デバイスドライバ、システムコールハンドラなどは、マイクロカーネル上で動作するいくつかのシステムプロセスが処理する。  

OSの学術的な研究は、マイクロカーネルの方向に進んでいる。  
しかし、マイクロカーネル方式のOSは一般的にモノリシックカーネルより実行速度が遅くなる。  
一方で、いくつかの点でマイクロカーネルに理論的な利点もある。
- システムプログラマにモジュール化方式を強要する
- マイクロカーネルのOSシステムを他のアーキテクチャに移植するのは比較的簡単
- モノリシックなカーネルよりRAMを効率よく利用できる

性能の低下を招くことなくマイクロカーネルの理論的な利点を効率よく実現できるようにカーネルはモジュール機能を提供する。  
モジュールは実行中にコードをカーネルに組み込む・削除することが可能なオブジェクトファイル。  

モジュールの主な利点には、次のようなものがある
- モジュール化方式
  - 実行時に組み込まれ削除される可能性がある
  - そのために明確に定義されたインタフェースがあり、新しいモジュールの開発が用意
- プラットフォーム独立性
  - ハードウェアプラットフォームに依存しない
  - ただし、ハードウェアの機能に依存することはある
- メインメモリの使用料を節約
  - 機能が必要になった時に実行中のカーネルに読み込める
  - 必要がなくなれば削除もできる
- 性能に関して妥協しない
  - 一度組み込まれてしまえば、カーネルに静的に組み込まれているオブジェクトコードと同様なので、明示的なメッセージパッシングは必要ない

## 1.5 UNIXファイルシステムの概要

UNIXオペレーティングシステムの設計の中心は、ファイルシステムにある。  
今後の章でもしばしば触れるので、この章では最も重要なものについて解説する。

### 1.5.1 ファイル

ファイルはツリー構造の名前空間に系統立てられている。(図1-1)  
- ルートディレクトリ
  - ツリーのルートにあるディレクトリ
- 作業ディレクトリ
  - プロセスごとにある現在使用しているディレクトリ
- パス名
  - ファイルに到達するまでの一連のディレクトリ名
  - 絶対パス名：先頭がスラッシュの場合。ルートディレクトリから開始
  - 相対パス名：開始地点がプロセスの作業ディレクトリ


### 1.5.2 ハードリンクとソフトリンク

ディレクトリ内のファイル名は、「ファイルハードリンク」または「リンク」と呼ばれている。  
1つのファイルの実態に対しtえ、同じディレクトリ内あるいは違うディレクトリ内に複数のリンクを持つことができる。  
つまり1角ファイルの実態が複数のファイル名を持つことができる。  

ハードリンクには２つの制限がある。
- ディレクトリのハートリンクは作れない
  - ディレクトリツリーが循環グラフになるのを防ぐため
- リンクは、同じファイルシステム内に含まれているファイルに対してのみ作成できる

同じファイルシステム内でしかリンクを作成できないのは近代のOSでは非常に不便。  
この制限を克服するために「ソフトリンク（シンボリックリンク）」が作成された。
シンボリックリンクは、別のファイルへの任意のパス名を含む小さなファイル。  
存在しないファイルを指し示すことも可能。


### 1.5.3 ファイルの種類

UNIXのファイルは以下のどれかになる。

- 通常ファイル
- ディレクトリ
- シンボリックリンク
- ブロック型デバイスファイル
- キャラクタ型デバイスファイル
- パイプ、名前付きパイプ、（FIFOとも呼ばれる）
- ソケット

これらの詳細は18章で、デバイスファイルについては13章で、パイプとソケットは1.6.5及び19章で述べる。


### 1.5.4 ファイルディスクリプタとiノード

UNIXではファイルの内容とファイル情報とを明確に区別している。  
ファイルを取り扱うのにファイルシステムが必要とする全ての情報はiノードに含まれている。  
ファイルシステムとそれを取り扱うカーネルの関数は、UNIXシステムの種類によって様々だが、少なくともPOSIX標準が定めている以下の属性は必ず提供されなければならない。  
- ファイルの種類
- ファイルに関連つけられているハードリンクの数
- ファイルのバイト長
- デバイス番号（ファイルがあるデバイスの識別子）
- ファイルシステムにおいてファイルを識別するiノード番号
- ファイル所有者のUID
- ファイルのGID
- iノード変更時刻、最終アクセス時刻、最終変更時刻を示す複数のタイムスタンプ
- アクセス権とファイルのモード


### 1.5.5 アクセス権とファイルのモード

ファイルのユーザは次の3つに分類できる。  
- ファイルの所有者であるユーザ
- ファイルのグループと同じグループに属する所有者以外のユーザ
- それ以外の全てのユーザ

上記のユーザごとに、読み取り、書き込み、実行3種類のアクセス権がある。  
したがって、ファイルのアクセス権は9つのバイナリフラグからなる。  
また、ファイルのモードを定義する補助的なフラグが3つある
- suid (Set User ID)
  - ファイルの実行は、通常プロセス所有者のユーザIDで実行される
  - suidが設定されていると、プロセスはファイル所有者のUIDで実行される
- sgid (Set Group ID)
  - 通常はプロセスのユーザグループで実行する
  - sgidが設定されていると、ファイルのGIDで実行される
- sticky
  - stickyフラグが設定されていると、実行が終了したあともメモリ内にプログラムを残しておくようにカーネルへ要求する

### 1.5.6 ファイルを取り扱うシステムコール

ユーザプロセスは低水準なハードウェアを直接操作することは出来ない。  
実際のファイル操作はカーネルモードで行われる必要がある。  
したがって、UNIXカーネルはファイルを操作するシステムコールを定義している。  
以降ではファイルを操作する主なシステムコールについて説明する


#### 1.5.6.1 ファイルのオープン

プロセスがアクセスできるのは「オープンされている」ファイルだけ  
プロセスはファイルをオープンするために以下のシステムコールを呼ぶ
```
fd = open(path, flag, mode)
```
- path
  - オープンするファイルの相対または絶対パス
- flag
  - ファイルをオープンする方法
    - 読み取り専用、書き込み専用など
    - ファイルが存在しない場合に新しく作成するかどうかの指定など
- mode
  - 新しく作成するファイルのアクセス権

このシステムコールはオープンファイルオブジェクトを作成し、ファイルディスクリプタという識別子を返す。  
オープンファイルオブジェクトには、以下のようなものが含まれる
- ファイルを操作するためのデータ
  - ファイルをオープンした時に指定したフラグなど
  - カーネルのバッファメモリ領域へのポインタや、次回操作が行われるファイル中の現在位置を示すoffsetメンバ
  - ファイルポインタと呼ばれることもある
- 複数のカーネル関数へのポインタ
  - プロセスから呼び出すことができるようにする
  - 呼び出し可能な関数の集合は、flag引数の値による

オープンファイルオブジェクトの詳細については、12章で述べる。  
ここではPOSIXで指定されているいくつかの一般的な属性を説明するだけにする。

- オープンファイルオブジェクトには、オープンされたファイルとプロセスとのやり取りや、制御に関連するデータが含まれている
- 一方、ファイルディスクリプタとは、どのやり取りかを指し示すもの、そのため、複数のファイルディスクリプタが同一プロセス内で同じオープンファイルオブジェクトを指すこともある。
- 複数のプロセスが同じファイルを同時にオープンすることもある。
  - この場合それぞれのプロセスに対して、別々のオープンファイルオブジェクトとともに、別々のファイルディスクリプタを割り当てる。
  - このような場合、UNIXファイルシステムでは、複数のプロセスに対して、同期処理の機構を提供しない
  - ただし、ファイルの全体あるいは一部に対して、プロセス同士が同期を取れるように、flock()などのシステムコールが利用できる(12章参照)

プロセスはcreate()システムコールを呼び出すこともでき、open()と全く同様に処理される。

#### 1.5.6.2 オープンされたファイルへのアクセス

UNIXはファイルの順次アクセスを前提としている。  
つまり、read()とwrite()システムコールは必ず現在のファイルポンターの位置を参照する。  
現在位置を変更したい場合には、プログラムは明示的にlseek()システムコールを呼び出す必要がある。  

lseek()システムコールには次のような引数が必要
```
newoffset = lseek(fd, offset, whence);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- offset
  - ファイルポインタの新しい値を計算するのに使用される符号付き整数値
- whence
  - 新しい一の計算方法を指定する値
    - offsetの値に数値0を足す
    - 現在のファイルポインタにoffsetの値を加える
    - 末尾のバイトの一にoffsetの値を加える

read()システムコールは以下の引数を必要とする
```
nread = read(fd, buf, count);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- buf
  - プロセスのアドレス空間にある、データ転送先のバッファアドレス
- count
  - 読み取るバイト数

read()システムコールはオープンされているファイルのoffsetメンバの現在地から始まるcountバイトをfdを持つファイルから読み取ろうとする。  
返されるnreadの値は、実際に読み取られたバイト数を示す。  
EOFや空のパイプなどの場合、カーネルがcountバイト数の読み取りに成功しないこともある。  

#### 1.5.6.3 ファイルのクローズ

ファイルディスクリプタfdい関連するオープンファイルオブジェクトを開放する
```
res = close(fd);
```

プロセスが終了された時も、その時点でまだオープンされていたファイルすべてがカーネルによってクローズされる。

#### 1.5.6.4 ファイル名変更とファイル削除

ファイルの名前を変えたり、ファイルを削除するとき、プロセスはそのファイルをオープンする必要はない。  
実際、このような操作は対象ファイルの中身ではなく、1つか2つのディレクトリの中身に対する操作である。  

例)  
ファイルリンクの名前を変更する
```
res = rename(oldpath, newpath);
```

ファイルのリンク数を1減らし、ディレクトリ内の対応するエントリを削除する。
（実際にはリンクカウントが0になったときにファイルが削除される）
```
res = ulink(pathname);
```

## 1.6 UNIX カーネルの概要

UNIXカーネルは、アプリケーションが動作する実行環境を提供する。
そのためカーネルは一連のサービスとそれに対応するインタフェースを実装しなければならない。  
アプリケーションはハードウェア資源を直接操作することはなく、インタフェースを利用する。

### 1.6.1 プロセス/カーネルモデル

CPUはユーザモードかカーネルモードで動作する。
実際には、CPUには2つ以上の実行状態を持てるものもあり、Intel 80x86プロセッサは4つの状態を持てる。  
しかし全ての標準的なUNIXカーネルは2つのモードだけを利用している。

カーネル自身はプロセスではなく、プロセスのマネージャ。  
プロセス/カーネルモデルでは、カーネルの差０ビスを必要とするプロセスは、システムコールを使用することが前提となっている。  
システムコールはプロセスからの要求を一意に決める引き数群を設定する。  
その後、ユーザモードからカーネルモードへ行こうし、ハードウェア依存のCPU命令を実行する

UNIXシステムには、ユーザプロセスの他にも、カーネルスレッド(kernel thread)と呼ばれる特権プロセスがいくつかある。  
その特徴は以下。
- カーネルアドレス空間に置いて、カーネルモードで動作する
- ユーザとのやり取りはないため、端末デバイスを必要としない
- システムの起動時に生成されるのが普通で、システムがシャットダウンされるまで動作し続ける

単一プロセッサシステムでは、任意の時点において1つのプロセスだけが実行されている。  
カーネルモードであれば、プロセッサは何らかのカーネルルーチンをじっこうしている。  

図1-2(p23)にユーザモード・カーネルモードが切り替わる様子

UNIXカーネルはシステムコールを処理するだけではない。  
実際、カーネルルーチンは以下に示す様々な方法によって駆動される。

- プロセスによるシステムコールの発行
- プロセスを実行中のCPUによる例外信号の発生
  - 例外とは命令が無効などの何らかの異常な状態のこと
  - 原因となったプロセスに変わってカーネルが例外を処理する
- 周辺デバイスからのCPUへの割り込み信号(interrupt signal)の発行
  - データが届いた等、CPUの注意を換気するためや、状態の変更、I/O操作の完了などの事象を知らせるためのもの
  - 書く割り込み信号は、割り込みハンドラ(interrupt handler)に処理される
  - 周辺デバイスはCPUとは非同期的に動作するので、割り込みは予測不可能な時点で発生する
- カーネルスレッドの実行
  - カーネルスレッドはカーネルモードで実行されるため、対応するプログラムはカーネルの一部とみなされる

### 1.6.2 プロセスの実装
カーネルによるプロセスの管理を実現するため、各プロセスはプロセスディスクリプタ(process discriptor)によって表される。  
プロセスディスクリプタにはプロセスの現在の状態についての情報が含まれている。

カーネルはプロセスの実行を停止する際、その時点でのプロセッサレジスタの内容をプロセスディスクリプタの中に退避する。  
- プログラムカウンタ(PC)レジスタとスタックポインタ(SP)レジスタ
- 汎用レジスタ
- 浮動小数点レジスタ
- プロセッサ制御レジスタ（プロセッサステータスワード、CPUの状態についての情報）
- メモリ管理レジスタ（プロセスが使用するRAMの管理）

カーネルはプロセスの実行再開を決めると、対比しておいたCPUレジスタを復旧するために、対応するプロセスディスクリプタのメンバを使用する。  


### 1.6.3 再入可能なカーネル
全てのUNIXカーネルは再入可能（リエントラント）。  
つまり同時に複数のプロセスをカーネルモードで実行することがある。  

再入可能性を実現する方法の1つはローカルな変数を変更し、グローバルな変数を変更しないような関数を書くこと。  
このような再入可能関数だけで、再入可能なカーネルが実現されているわけではない。（一部のリアルタイムカーネルはこの方法で実装されている）  
カーネルは再入不可能な関数を実行する場合、ロック機構を使って、その関数を実行するプロセスがその時点で1つだけであることを保証する。  

再入可能なカーネルでは、カーネルモードで実行中のプロセスであっても、現在実行中のプロセスを一時停止することが出来る。(性能のために非常に重要)

カーネルの再入可能性と、カーネルの構造に及ぼす影響について注目してみる。  
カーネル実行パス(kernel control path)とは、システムコール、例外、割り込みを処理するためにカーネルに酔って実行される命令シーケンスのこと。

- ユーザモードで実行中のプロセスに酔ってシステムコールが発行されたが、対応するカーネル実行パスではその要求を即座に完了できないことが確認された場合
  - 新しく実行するプロセスを選ぶためにスケジューラを呼び出す。
  - その結果、プロセス切り替えが行われる。
  - 最初のカーネルパスは未完了のまま残され、CPUは別のカーネル実行パスの実行を再開する。
  - この場合、それぞれのプロセスに対応した異なる2つの実行パスが実行される

- カーネルが実行パスを実行中、CPUが例外を検出した場合
  - 最初の実行パスは一時停止され、CPUは対応する適切な処理を開始する。
  - 例外に対する処理が終了すると、細書の実行パスを再開することが出来る。

- 割り込み許可の状態でCPUがカーネル実行パスを実行中に、ハードウェア割り込みが発生した場合
  - CPUは割り込みを処理するために、別のカーネル実行パスの処理を開始する
  - 細書のカーネル実行パスは、割り込みハンドラが実行を終了すると、再開される。
  - この場合、2つのカーネル実行パスは、同じプロセスの実行コンテキスト内で実行される。
  - プロセスの経過システム時間はその合計とみなされる。
  - ただし、割り込みハンドラは、必ずしもそのプロセスのための処理を行っているとは限らない


- カーネル内プリエンプと可能な箇所で、CPUに割り込みが発生し、高い実行優先度のプロセスが実行可能になったとき
  - 細書のカーネル実行パスから、より高い実行優先度のプロセスのカーネル実行パスを再開する
  - これはカーネル内プリエンプション可能となるように、カーネルをコンパイルしている場合にのみ起こる

割り込みがない場合と、ある場合のカーネル実行パスの例を図1-3(p.26)に示す
- プロセスをユーザモードで実行中(User)
- 例外またはシステムコールの処理を実行中(Excp)
- 割り込み処理を実行中(Intr)


### 1.6.4 プロセスアドレス空間
プロセスは、それぞれの固有うなアドレス空間において実行される。  
ユーザモードとカーネルモードでそれぞれ固有のスタックを使う。  

各プロセスが固有なアドレス空間にアクセスしているかのように見えていても、固有のアドレス空間の一部が複数のプロセスによって共有されている場合もある。  
この共有は、プロセスに酔って明示的に要求されることもあれば、メモリ使用量を減らすためにカーネルが自動的に行うこともある。    
同時に複数のユーザに酔って同じプログラム（例えばエディタ）を必要とする場合、そのプログラムがメモリに読み込まれるのは一度だけ。  
プログラム中の命令は必要としている全てのユーザで共有することが出来る。  
もちろんユーザごとに別々のデータになるため、データは共有してはいけない。  
この種のアドレス空間の共有は、メモリの節約のためにカーネルが自動的におこなう。  

プロセウはプロセス間通信の一種を使ってアドレス空間の一部wお共有することも出来る。
SystemVで道有され、Linuxでも提供されている「共有メモリ」手法が利用されている。
更に、Linuxではmmap()システムコールを備えている。  
このシステムコールは、ファイルブロック型デバイス内の情報をプロセスアドレス空間の一部へマッピングするもの。  
メモリマッピングは、通常のread/writeシステムコールの代わりとして、データ転送に使用することも出来る。  
複数のプロセスに酔って共有されている同じファイルのメモリマッピングは、共有している各プロセスそれぞれのアドレス空間内に割り当てられる。  


### 1.6.5 同期とクリティカル区間



#### 1.6.5.1 カーネル内プリエンプとの禁止



#### 1.6.5.2 割り込みの禁止



#### 1.6.5.3 セマフォ



#### 1.6.5.4 スピンロック



#### 1.6.5.5 デッドロックの回避



### 1.6.6 シグナルとプロセス間通信


### 1.6.7 プロセス管理


#### 1.6.7.1 ゾンビプロセス


#### 1.6.7.2 プロセスグループとログインセッション



### 1.6.8 メモリ管理



#### 1.6.8.1 仮想記憶


#### 1.6.8.2 ランダムアクセスメモリの使用



#### 1.6.8.3 カーネルメモリアロケータ




#### 1.6.8.4 プロセスの仮想アドレス空間の取り扱い



#### 1.6.8.5 キャッシュ


### 1.6.9 デバイスドライバ






.
