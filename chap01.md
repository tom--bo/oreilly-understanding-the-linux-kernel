# chapter-01 概要

Linuxは1991年から最初はIntel 80386プロセッサベースのIBM PC互換機用のOSとして、Linus Torvaldsにより開発された。  
Linuxの魅力の１つは商用ではないことで、GNU一般公衆利用許諾契約書(GNU General Public License:以降GPL)に基づいて公開されている。  
そのため、誰でも自由に調べたり、ダウンロードしたりできる。  

## 1.1 LinuxとほかのUNIX系カーネル

市場にはさまざまなUNIX系システムが出回っている  
商用UNIXはすべて、IEEEのPOSIX(Portable Operating Systems based on Unix)やX/OpenのCAE(Common Applications Environment)といった一般的な標準規格に従う傾向がある。  
現在の標準規格では、API(Application Programming Interface)、つまり、ユーザプログラムが実行される環境のみが規定されている  
共通のユーザインタフェースを定義するため、UNIX系カーネルでは多くの場合基本的な設計思想や機能が共有されている。  
この点はLinuxは他のUNIX系OSと類似しているので、Linuxで学んだことはUNIXの理解にも役立つ。

Linuxカーネルのバージョン2.6はIEEE POSIX標準への準拠を目指しているので、既存のUNIXプログラムの殆どがLinuxシステム上でコンパイルして実行できるようになる。  
更に、仮想ファイルシステム、軽量プロセス、UNIXシグナル、SVR4プロセス間通信、対象型マルチプロセッサ(Symmetric MultiProcessor(以下SMP))システムが扱えるなど、近代的なUNIX OSの持つ機能をLinuxは全て備えている。  

Linus Torvaldsはカーネルを書き始める時に、Maurice Bach著「The Design of the Unix Operating System」のようなUNIXの古典的な本を参考にしたため、UNIXの設計方針に偏っているところがある。
以下にLinuxと他の代表的な商用UNIXカーネルを比較、評価した結果を挙げる。

- モノリシックカーネル(一枚岩)
  - Linuxカーンるはおおきく複雑で自己完結的なプログラム
  - UNIX系OSの殆どもモノリシック
  - モノリシックと相対する構造をもつのは、Mac OS XとGNU Hurd OSが有名でこれらは、マイクロカーネルという方式をとっている
- 伝統的なUNIXカーネルのコンパイルとリンクは静的
  - 近代的なカーネルならば、たいていカーネルコードの一部を動的に組み込んだり、削除したりできる
  - これはモジュールと呼ばれ、典型的な例はデバイスドライバ
  - Linuxのモジュール支援機構は非常にす売れていて、必要に応じてこれらを自動的に組み込んだり削除したりできる
- カーネルスレッド
  - 近代的なUNIXカーネルは、カーネルスレッドの集合体として構成されている
  - カーネルスレッドとは、独立してスケジューリングが可能な実行コンテキスト
  - カーネルスレッドには、ユーザプログラムに対応するものもあれば、カーネルの関数に対応するだけのものもある
  - カーネルスレッドは共通のアドレス空間で実行されるので、プロセス間のコンテキスト切り替えよりずっと効率が良いことが多い
  - Linuxでは、カーネルスレッドを、定期的にいくつかのカーネル関数を実行するという限定された方法でしか使用していない
- マルチスレッドアプリケーション支援
  - マルチスレッドなアプリケーションとは、アプリケーションのデータのかなりの部分を共有し、比較的独立した多くの処理の流れを取り扱えるように設計されたユーザプログラムのこと
  - マルチスレッドなユーザアプリケーションは多くの軽量プロセス(LightWeight Process、以下LWP)から構成される場合もある
  - Linuxでは、独自のLWPを定義している
    - 基本的な実行コンテキスト(プロセスと同じ)とみなされ
    - 標準的ではないclone()というシステムコールで処理される
- マルチプロセッサ支援
  - SMP機能を提供し、NUMAのような異なるメモリモデルのものも扱える
- ファイルシステム
  - Linuxの標準ファイルシステムに多くの機能が追加された
  - Ext2, Ext3, ReiserFS, JFS, XFSなど
- STREAMS
  - SVR4で導入されているSTREAMS I/Oサブシステムは、最近ではほとんどのUNIXカーネルに用意されるが、Linuxにこれに類似するものはない

以上のような特徴の他に、商用のUNIXと比べて以下のような利点がある

- Linuxは無料である
- Linuxでは全ての構成部分をカスタマイズできる
- Linuxはローエンドで安価なハードウェアプラットフォーム上でも動作する
- Linuxは強力である
- Linuxカーネル開発者は卓越したプログラマである
- Linuxカーネルは非常に小さくすることができる
- Linuxは多くの一般的なOSとの互換性が高い
- Linuxには優れたサポートがある

## 1.2 ハードウェア依存

Linuxではソースコードのハードウェアに依存する部分と非依存の部分を明確に区別している。  
そのため、archディレクトリとincludeディレクトリの両方に23種類のハードウェアプラットフォームに対応するサブディレクトリをおいている。

プラットフォームの標準名（ここでは代表的なのいくつか）
- arm, arm26
- i386
- MIPS
- x86_64

## 1.3 Linuxのバージョン

Linuxカーネル2.5までは単純な番号体型でバージョンをつけていた。  
ピリオドによって3つに区切られた、最初の2つがバージョンを特定し、３つめがリリース番号  
2.5までは2つ目の数字が偶数であれば安定版、奇数であれば開発版を意味していたが、2.6以降はそうではない。


## 1.4 オペレーティングシステムの基本概念

この本では多くの場合は「オペレーティングシステム」と「カーネル」を同義として扱う。  
オペレーティングシステムは、2つの重要な役割がある
- 低水準のプログラマブルなハードウェアを制御する
- コンピュータシステム上で実行するアプリケーションに実行環境を提供する

OSの中にはWindowsのようにユーザプログラムにハードウェアを直接操作することを認めているものもある。  
一方、UNIX系のOSではユーザプログラムにはこれらを隠蔽している

近代的なOSではこの仕組みを実現するために、ハードウェアに備わっている特定の機能に依存している。  
具体的には、ハードウェアはCPUに少なくとも2つの異なる実行モードを用意している  
それぞれをユーザモードとカーネルモードと呼ぶ  
以降のこの章ではこれらの基本的な概念を紹介し、2章以降ではLinuxカーネル内部機構を理解するための内容が続く。

### 1.4.1 マルチユーザシステム

マルチユーザシステムとは2人以上のユーザが様々なアプリケーションを並行して独立に実行することが可能なコンピュータ  
- 並行に：複数のアプリケーションが同時に動作状態になり、CPU、メモリ、ディスクなどの様々な資源を取り合うことができる
- 独立に：他のユーザのアプリケーションの動作とは無関係に処理を実行できる

マルチオペレーティングシステムには以下のような機能が必要
- ユーザIDを確認する認証機構
- 同じシステム上で他のアプリケーションの動きを止めてしまう可能性のあるバグをもつユーザプログラムに対する保護機構
- 悪意のあるユーザプログラムに対するする保護機構
- 各ユーザに割り当てる資源の量を制限するアカウンティング機構

保護機構の安全性を保証するために、オペレーティングシステムはハードウェア(CPUの特権モード)による保護を利用する必要がある。


### 1.4.2 ユーザとグループ

マルチユーザシステムでは、マシン上に各ユーザの個人領域がある。
ユーザは全て、ユーザID(UID)と呼ばれる一意の番号によって識別される。  
ユーザがセッションを開始するには、ログイン名とパスワードが要求される。
他のユーザとデータを共有するために各ユーザは１つ以上のユーザグループに所属する。  
グループはユーザグループID(GID)によって識別される。  
全てのUNIX系オペレーティングシステムには、ルート(スーパユーザ、スーパバイザ)と呼ばれるシステムの管理用ユーザがある。  
ルートユーザはシステムの全てのユーザプログラムの実行を操作することができる。


### 1.4.3 プロセス

プロセスは「実行中のプログラムのインスタンス」または、動作中のプログラムの「実行コンテキスト」と定義できる。  
プロセスは1つのアドレス空間において、命令の並び（命令シーケンス）を1つ以上実行する。  
マルチユーザシステムでは、複数のプロセスが同時に動作状態になり、システム資源（おもにCPU）を取り合うという実行環境を提供しなければならない。  
複数のプロセスが同時に動作状態になることが可能なシステムのことを、「マルチプログラミングシステム」または「マルチプロセッシングシステム」という。  

一般的にCPUの数は限られているので、同時に実行できるのは数プロセスだけ。  
OSのスケジューラが実行するプロセスを選択する。  
マルチユーザシステムのプロセスは「プリエンプト可能」でなければならない。つまり、OSが各プロセスがCPUを獲得していた時間を管理し、定期的にスケジューラを作動する。  
UNIX系OSでは「プロセス/カーネル」モデルが採用されていて、各プロセスは自分がマシン上の唯一のプロセスであり、OSのサービスを専有していると錯覚している。  

### 1.4.4 カーネルアーキテクチャ

UNIXカーネルの殆どはモノリシック。カーネル内の各レイヤはカーネルプログラム全体へと統合され、カレントプロセスの代わりにカーネルモードで動作する。  
対象的に、マイクロカーネル方式のOSでは、カーネルに要求される機能はわずかである。  
一般的には、数種類の動機プリミティブ、単純なスケジューラ、プロセス間通信機構などがある。  
その他のOSレイヤの機能、メモリアロケータ、デバイスドライバ、システムコールハンドラなどは、マイクロカーネル上で動作するいくつかのシステムプロセスが処理する。  

OSの学術的な研究は、マイクロカーネルの方向に進んでいる。  
しかし、マイクロカーネル方式のOSは一般的にモノリシックカーネルより実行速度が遅くなる。  
一方で、いくつかの点でマイクロカーネルに理論的な利点もある。
- システムプログラマにモジュール化方式を強要する
- マイクロカーネルのOSシステムを他のアーキテクチャに移植するのは比較的簡単
- モノリシックなカーネルよりRAMを効率よく利用できる

性能の低下を招くことなくマイクロカーネルの理論的な利点を効率よく実現できるようにカーネルはモジュール機能を提供する。  
モジュールは実行中にコードをカーネルに組み込む・削除することが可能なオブジェクトファイル。  

モジュールの主な利点には、次のようなものがある
- モジュール化方式
  - 実行時に組み込まれ削除される可能性がある
  - そのために明確に定義されたインタフェースがあり、新しいモジュールの開発が用意
- プラットフォーム独立性
  - ハードウェアプラットフォームに依存しない
  - ただし、ハードウェアの機能に依存することはある
- メインメモリの使用料を節約
  - 機能が必要になった時に実行中のカーネルに読み込める
  - 必要がなくなれば削除もできる
- 性能に関して妥協しない
  - 一度組み込まれてしまえば、カーネルに静的に組み込まれているオブジェクトコードと同様なので、明示的なメッセージパッシングは必要ない

## 1.5 UNIXファイルシステムの概要

UNIXオペレーティングシステムの設計の中心は、ファイルシステムにある。  
今後の章でもしばしば触れるので、この章では最も重要なものについて解説する。

### 1.5.1 ファイル

ファイルはツリー構造の名前空間に系統立てられている。(図1-1)  
- ルートディレクトリ
  - ツリーのルートにあるディレクトリ
- 作業ディレクトリ
  - プロセスごとにある現在使用しているディレクトリ
- パス名
  - ファイルに到達するまでの一連のディレクトリ名
  - 絶対パス名：先頭がスラッシュの場合。ルートディレクトリから開始
  - 相対パス名：開始地点がプロセスの作業ディレクトリ


### 1.5.2 ハードリンクとソフトリンク

ディレクトリ内のファイル名は、「ファイルハードリンク」または「リンク」と呼ばれている。  
1つのファイルの実態に対しtえ、同じディレクトリ内あるいは違うディレクトリ内に複数のリンクを持つことができる。  
つまり1角ファイルの実態が複数のファイル名を持つことができる。  

ハードリンクには２つの制限がある。
- ディレクトリのハートリンクは作れない
  - ディレクトリツリーが循環グラフになるのを防ぐため
- リンクは、同じファイルシステム内に含まれているファイルに対してのみ作成できる

同じファイルシステム内でしかリンクを作成できないのは近代のOSでは非常に不便。  
この制限を克服するために「ソフトリンク（シンボリックリンク）」が作成された。
シンボリックリンクは、別のファイルへの任意のパス名を含む小さなファイル。  
存在しないファイルを指し示すことも可能。


### 1.5.3 ファイルの種類

UNIXのファイルは以下のどれかになる。

- 通常ファイル
- ディレクトリ
- シンボリックリンク
- ブロック型デバイスファイル
- キャラクタ型デバイスファイル
- パイプ、名前付きパイプ、（FIFOとも呼ばれる）
- ソケット

これらの詳細は18章で、デバイスファイルについては13章で、パイプとソケットは1.6.5及び19章で述べる。


### 1.5.4 ファイルディスクリプタとiノード

UNIXではファイルの内容とファイル情報とを明確に区別している。  
ファイルを取り扱うのにファイルシステムが必要とする全ての情報はiノードに含まれている。  
ファイルシステムとそれを取り扱うカーネルの関数は、UNIXシステムの種類によって様々だが、少なくともPOSIX標準が定めている以下の属性は必ず提供されなければならない。  
- ファイルの種類
- ファイルに関連つけられているハードリンクの数
- ファイルのバイト長
- デバイス番号（ファイルがあるデバイスの識別子）
- ファイルシステムにおいてファイルを識別するiノード番号
- ファイル所有者のUID
- ファイルのGID
- iノード変更時刻、最終アクセス時刻、最終変更時刻を示す複数のタイムスタンプ
- アクセス権とファイルのモード


### 1.5.5 アクセス権とファイルのモード

ファイルのユーザは次の3つに分類できる。  
- ファイルの所有者であるユーザ
- ファイルのグループと同じグループに属する所有者以外のユーザ
- それ以外の全てのユーザ

上記のユーザごとに、読み取り、書き込み、実行3種類のアクセス権がある。  
したがって、ファイルのアクセス権は9つのバイナリフラグからなる。  
また、ファイルのモードを定義する補助的なフラグが3つある
- suid (Set User ID)
  - ファイルの実行は、通常プロセス所有者のユーザIDで実行される
  - suidが設定されていると、プロセスはファイル所有者のUIDで実行される
- sgid (Set Group ID)
  - 通常はプロセスのユーザグループで実行する
  - sgidが設定されていると、ファイルのGIDで実行される
- sticky
  - stickyフラグが設定されていると、実行が終了したあともメモリ内にプログラムを残しておくようにカーネルへ要求する

### 1.5.6 ファイルを取り扱うシステムコール

ユーザプロセスは低水準なハードウェアを直接操作することは出来ない。  
実際のファイル操作はカーネルモードで行われる必要がある。  
したがって、UNIXカーネルはファイルを操作するシステムコールを定義している。  
以降ではファイルを操作する主なシステムコールについて説明する


#### 1.5.6.1 ファイルのオープン

プロセスがアクセスできるのは「オープンされている」ファイルだけ  
プロセスはファイルをオープンするために以下のシステムコールを呼ぶ
```
fd = open(path, flag, mode)
```
- path
  - オープンするファイルの相対または絶対パス
- flag
  - ファイルをオープンする方法
    - 読み取り専用、書き込み専用など
    - ファイルが存在しない場合に新しく作成するかどうかの指定など
- mode
  - 新しく作成するファイルのアクセス権

このシステムコールはオープンファイルオブジェクトを作成し、ファイルディスクリプタという識別子を返す。  
オープンファイルオブジェクトには、以下のようなものが含まれる
- ファイルを操作するためのデータ
  - ファイルをオープンした時に指定したフラグなど
  - カーネルのバッファメモリ領域へのポインタや、次回操作が行われるファイル中の現在位置を示すoffsetメンバ
  - ファイルポインタと呼ばれることもある
- 複数のカーネル関数へのポインタ
  - プロセスから呼び出すことができるようにする
  - 呼び出し可能な関数の集合は、flag引数の値による

オープンファイルオブジェクトの詳細については、12章で述べる。  
ここではPOSIXで指定されているいくつかの一般的な属性を説明するだけにする。

- オープンファイルオブジェクトには、オープンされたファイルとプロセスとのやり取りや、制御に関連するデータが含まれている
- 一方、ファイルディスクリプタとは、どのやり取りかを指し示すもの、そのため、複数のファイルディスクリプタが同一プロセス内で同じオープンファイルオブジェクトを指すこともある。
- 複数のプロセスが同じファイルを同時にオープンすることもある。
  - この場合それぞれのプロセスに対して、別々のオープンファイルオブジェクトとともに、別々のファイルディスクリプタを割り当てる。
  - このような場合、UNIXファイルシステムでは、複数のプロセスに対して、同期処理の機構を提供しない
  - ただし、ファイルの全体あるいは一部に対して、プロセス同士が同期を取れるように、flock()などのシステムコールが利用できる(12章参照)

プロセスはcreate()システムコールを呼び出すこともでき、open()と全く同様に処理される。

#### 1.5.6.2 オープンされたファイルへのアクセス

UNIXはファイルの順次アクセスを前提としている。  
つまり、read()とwrite()システムコールは必ず現在のファイルポンターの位置を参照する。  
現在位置を変更したい場合には、プログラムは明示的にlseek()システムコールを呼び出す必要がある。  

lseek()システムコールには次のような引数が必要
```
newoffset = lseek(fd, offset, whence);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- offset
  - ファイルポインタの新しい値を計算するのに使用される符号付き整数値
- whence
  - 新しい一の計算方法を指定する値
    - offsetの値に数値0を足す
    - 現在のファイルポインタにoffsetの値を加える
    - 末尾のバイトの一にoffsetの値を加える

read()システムコールは以下の引数を必要とする
```
nread = read(fd, buf, count);
```
- fd
  - オープンされたファイルのファイルディスクリプタ
- buf
  - プロセスのアドレス空間にある、データ転送先のバッファアドレス
- count
  - 読み取るバイト数

read()システムコールはオープンされているファイルのoffsetメンバの現在地から始まるcountバイトをfdを持つファイルから読み取ろうとする。  
返されるnreadの値は、実際に読み取られたバイト数を示す。  
EOFや空のパイプなどの場合、カーネルがcountバイト数の読み取りに成功しないこともある。  

#### 1.5.6.3 ファイルのクローズ

ファイルディスクリプタfdい関連するオープンファイルオブジェクトを開放する
```
res = close(fd);
```

プロセスが終了された時も、その時点でまだオープンされていたファイルすべてがカーネルによってクローズされる。

#### 1.5.6.4 ファイル名変更とファイル削除

ファイルの名前を変えたり、ファイルを削除するとき、プロセスはそのファイルをオープンする必要はない。  
実際、このような操作は対象ファイルの中身ではなく、1つか2つのディレクトリの中身に対する操作である。  

例)  
ファイルリンクの名前を変更する
```
res = rename(oldpath, newpath);
```

ファイルのリンク数を1減らし、ディレクトリ内の対応するエントリを削除する。
（実際にはリンクカウントが0になったときにファイルが削除される）
```
res = ulink(pathname);
```




.
